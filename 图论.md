图论
==

## 图的存储

### 直接存储

```cpp
//代码更少的做法
vector<tuple<int,int,int>> e(m);
for(auto &[f, t, w] : e) {
	cin >> f >> t >> w;
//	-- u, -- v;
}
//-----------------------------------------------
struct edge {
    int f, t, w;
};
vector<edge> e(m);
for(int i = 0; i < m; i ++) {
    cin >> e[i].f >> e[i].t >> e[i],w;
}
```



### 邻接矩阵

```cpp
vector<vector<bool>> e(n, vector<bool> (n, 0));
或者
bool e[N][N];
```



### 邻接表

```cpp
拉链法，每个点都开一个vector
vector<int> e(n);
```



### 链式前向星（快）

```cpp
链表实现邻接表
int e[N * M], ne[N * M], idx, head[N];
memset(head, - 1, sizeof head);
void add(int f, int t) {
	e[idx] = t, ne[idx] = head[f], head[f] = idx ++;
}
```



## DFS

```cpp
利用函数栈空间来实现
标记节点是否被遍历过，递归到下一层
void DFS (int x) {
	ban[x] = 1;
    for(auto it : e[x]) {
		if(!ban[it])
        	DFS(it);
    }
}
```

## BFS

```cpp
手写队列来实现
基本做法：
    每次拿出队头元素，搜索每个子节点并标记并将每个子节点放入队列中去
void BFS (int x) {
	queue<int> q;
    q.push(x);
    ban[x] = 1;
    while(!q.empty()) {
        int t = q.front ();
        q.pop();
		for(auto it : e[t]) {
			if(!ban[it]) {
            	q.push(it);
            	ban[it] = 1;
            }
        }
    }
}
```



## 有向图的拓扑排序

```cpp
排序后，边的方向都由前指向后
基本思路：
    1、让所有入度为0的点入队
    2、BFS，每次遍历都删去被遍历的边，即让终点的入度--
    3、让入度减为0的点出队
    4、数组模拟的队列可以直接输出，STL的队列需要将中间出队的点都存下来
vector<int> d(n + 1, 0), q(n);
vector<vector<int>> e(n +);
bool topsort() {
	head = 0, tail = - 1;
    for(int i = 1;i <= n;i ++) {
		if(d[i] == 0) {
			q[++ tail] = i;
        }
    }
    while(tail >= head) {
		int t = q[head ++];
        for(auto it : e[t]) {
            d[it] --;
            if(!d[it])
                q[++ tail] = it;
        }
    }
	return tail == n - 1;
}

for(int i = 0;i < m;i ++) {
    int f, t;
    cin >> f >> t;
	//add(f, t);
    //d[t] ++;
}
```

## 最短路

### Dijkstra

适用于非负权值图

#### 具体流程：

1、创建一个集合$S$存放已经确认最短路的点

2、初始化dis数组为$ +\infty$，将源点的dis赋为$0$

3、在未被添加到$S$集合中的点中选择dis最小的点添加到$S$中

4、更新每个dis的上限

5、重复操作3和4，直至所有点都在$S$集合中

##### 暴力做法：

时间复杂度$O(n^2 + m)$

```cpp
typedef pair<int, int> PII;
vector<vector<PII>> e;
vector<int> dis；
vector<bool> vis;
int n, m;
void dijkstra(int n, int s) {
    dis.resize(n + 1,0x3f3f3f3f);
    vis.resize(n + 1, 0);
    dis[s] = 0;
    for(int i = 1;i <= n;i ++) {
        int u = 0, mind = 0x3f3f3f3f;
        for(int j = 1;j <= n;j ++) {
            if(dis[j] < mind && !vis[j]) {
                u = j, mind = dis[j];
            }
        }
        vis[u] = 1;
        for(auto it : e[u]) {
            int v = it.first, w = it.second;
            if(dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
            }
        }
    }
}
```



##### 优先队列优化做法：

时间复杂度$O(m\ log\ m)$

```cpp
```



##### 二叉堆优化做法：

时间复杂度$O(m\ log\ n)$

```cpp
```



### Bellman-Ford

### SPFA

### Floyd
