# 补题集

## 并查集

#### CF1624G

([Problem - G - Codeforces](https://codeforces.com/contest/1624/problem/G))

题目大意：给你一张无向图，保留n - 1条边使之成为生成树，使得生成树路径的或和最小

解题思路：并查集 + 贪心， 从高到低判断每一位二进制上能否为0，如果取0时可以包含全部点，则该位上取0并将所有该位为1的边都删去，反之则取1。

参考代码：

```cpp
struct edge {
    int f, t, w;
    bool ban = 0;
};
vector<edge> e;
vector<int> p;
int find(int x) {
	if(p[x] != x) {
		p[x] = find(p[x]);
    }
	return p[x];
}
void solve() {
	int n, m;
    long long res = 0;
    cin >> n >> m;
    e.resize(m);
    p.resize(n + 1);
    for(auto &i : e) {
		cin >> i.f >> i.t >> i.w;
        i.ban = 0;
    }
    for(int i = 30; i >= 0; i --) {
		for(int j = 1; j <= n; j ++) {
            p[j] = j;
        }
		int cnt = 0;
        for(auto &it : e) {
            int r1 = find(it.f), r2 = find(it.t);
            if(!(it.w & (1 << i)) && !it.ban && r1 != r2) {
                p[r2] = r1;
                cnt ++;
            }
        }
        bool ok = (cnt >= n - 1);
        if(ok) {
            for(auto &it : e) {
                if((it.w & (1 << i))) it.ban = 1;
            }
        }
        else {
            res += (1 << i);
        }
    }
    cout << res << '\n';
}
```

#### POJ1182

([1182 -- 食物链 (poj.org)](http://poj.org/problem?id=1182))

题目大意：存在一条食物链A->B->C->A，现在对n个物种，k个人每个人都对其进行了描述，1 x y表示x y是同列，2 x y表示x吃y，如果认为先说的人是正确的，那么问有多少个人说了假话。

解题思路：对每个节点都保存该节点与其父节点的相对关系，0表示同类，1表示被父节点吃，2表示吃父节点，推导出路径压缩的权值转换公式，以及合并的权值转换公式。

参考代码：

```cpp
vector<int>p, val;
int find(int x) {
    if(p[x] != x) {
		int tmp = p[x];
        p[x] = find(p[x]);
        val[x] = (val[x] + val[tmp] ) % 3;
    }
    return p[x];
}
bool merge(int op, int x, int y) {
	int r1 = find(x), r2 = find(y);
    if(r1 != r2) {
		p[r2] = r1;
        val[r2] = (2 + op + val[x] - val[y]) % 3;
    }
    else {
		if(val[r2] != (2 + op + val[x] - val[y]) % 3) {
            return 1;
        }
    }
    return 0;
}
void solve() {
    int n, k, res = 0;
    cin >> n >> k;
    p.resize(n + 1);
    val.resize(n + 1);
    for(int i = 1; i <= n;i ++) {
		p[i] = i;
        val[i] = 0;
    }
    while(k --) {
        int op, x, y;
        cin >> op >> x >> y;
        if(x > n || y > n) {
			res ++;
            continue;
        }
        if(merge(op, x, y)) res ++;
    }
}
```

