# 补题集

## 并查集

#### CF1624G

([Problem - G - Codeforces](https://codeforces.com/contest/1624/problem/G))

题目大意：给你一张无向图，保留n - 1条边使之成为生成树，使得生成树路径的或和最小

解题思路：并查集 + 贪心， 从高到低判断每一位二进制上能否为0，如果取0时可以包含全部点，则该位上取0并将所有该位为1的边都删去，反之则取1。

参考代码：

```cpp
struct edge {
    int f, t, w;
    bool ban = 0;
};
vector<edge> e;
vector<int> p;
int find(int x) {
	if(p[x] != x) {
		p[x] = find(p[x]);
    }
	return p[x];
}
void solve() {
	int n, m;
    long long res = 0;
    cin >> n >> m;
    e.resize(m);
    p.resize(n + 1);
    for(auto &i : e) {
		cin >> i.f >> i.t >> i.w;
        i.ban = 0;
    }
    for(int i = 30; i >= 0; i --) {
		for(int j = 1; j <= n; j ++) {
            p[j] = j;
        }
		int cnt = 0;
        for(auto &it : e) {
            int r1 = find(it.f), r2 = find(it.t);
            if(!(it.w & (1 << i)) && !it.ban && r1 != r2) {
                p[r2] = r1;
                cnt ++;
            }
        }
        bool ok = (cnt >= n - 1);
        if(ok) {
            for(auto &it : e) {
                if((it.w & (1 << i))) it.ban = 1;
            }
        }
        else {
            res += (1 << i);
        }
    }
    cout << res << '\n';
}
```

#### POJ1182

([1182 -- 食物链 (poj.org)](http://poj.org/problem?id=1182))

题目大意：存在一条食物链A->B->C->A，现在对n个物种，k个人每个人都对其进行了描述，1 x y表示x y是同列，2 x y表示x吃y，如果认为先说的人是正确的，那么问有多少个人说了假话。

解题思路：对每个节点都保存该节点与其父节点的相对关系，0表示同类，1表示被父节点吃，2表示吃父节点，推导出路径压缩的权值转换公式，以及合并的权值转换公式。

参考代码：

```cpp
vector<int>p, val;
int find(int x) {
    if(p[x] != x) {
		int tmp = p[x];
        p[x] = find(p[x]);
        val[x] = (val[x] + val[tmp] ) % 3;
    }
    return p[x];
}
bool merge(int op, int x, int y) {
	int r1 = find(x), r2 = find(y);
    if(r1 != r2) {
		p[r2] = r1;
        val[r2] = (2 + op + val[x] - val[y]) % 3;
    }
    else {
		if(val[r2] != (2 + op + val[x] - val[y]) % 3) {
            return 1;
        }
    }
    return 0;
}
void solve() {
    int n, k, res = 0;
    cin >> n >> k;
    p.resize(n + 1);
    val.resize(n + 1);
    for(int i = 1; i <= n;i ++) {
		p[i] = i;
        val[i] = 0;
    }
    while(k --) {
        int op, x, y;
        cin >> op >> x >> y;
        if(x > n || y > n) {
			res ++;
            continue;
        }
        if(merge(op, x, y)) res ++;
    }
}
```

## 数学

#### CF1618E

([Problem - E - Codeforces](https://codeforces.com/contest/1618/problem/E))

题目大意：n个城市依次（1，2，3，4，...，n）连成环，每个城市都有一名歌手，每个歌手从自己的城市出发，顺时针演唱一圈，依次演唱a~i~, 2a~i~, 3a~i~, ..., na~i~分钟，现在每一座城市总共演唱b~i~分钟，问是否存在a~i~数组使之成立。

解题思路：即求如下图所示的增广矩阵

$$\begin{bmatrix}
1&n&n-1&{\cdots}&2&b_1\\
2&1&n&{\cdots}&3&b_2\\
3&2&1&{\cdots}&4&b_3\\
{\vdots}&{\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\
n&n-1&n-2&{\cdots}&1&b_n\\
\end{bmatrix}$$

我们不难发现，将每行相加可以得到
$\sum_{i = 1}^{n}b_i = \frac{(n + 1)  \times n}{2} \times \sum_{i = i}^{n}a_i$

因此首先可以判断$\sum_{i = 1}^{n}b_i\ \  mod\ \ \frac{(n + 1)  \times n}{2}$是否为0，并求出$\sum_{i = i}^{n}a_i$的值

其次发现相邻的两行相减可以得到

$b_i - b_{(i + n - 2\ mod\ n) +\ 1} = \sum_{i = i}^{n}a_i - n\times a_i$

由此可以求得所有$a_i$的值，但需要排除$a_i$为非正整数的情况。

参考代码：

```cpp
void solve() {
	int n;
    ll sum = 0;
    cin >> n;
    vector<int> b(n), a(n);
    for(auto & x : b) {
        cin >> x;
        sum += x;
    }
    if((sum % ((n + 1) * n / 2)) != 0) {
        cout << "NO\n";
        return ;
    }
    sum /= ((n + 1) * n / 2);
    for(int i = 0;i < n;i ++) {
        a[i] = sum - (b[i] - b[(i + n - 1) % n]);
        if(a[i] <= 0 || (a[i] % n) != 0) {
			cout << "NO\n";
        	return ;
        }
        a[i] /= n;
    }
    cout << "YES\n";
    for(auto x : a) {
		cout << x << ' ';
    }
    cout << "\n";
}
```



